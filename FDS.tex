\documentclass[12pt,openany, tikz,border=10pt]{book}


% Load packages
\usepackage[utf8]{inputenc} % for unicode input
 \usepackage{microtype}
\usepackage{geometry} % for page layout
\usepackage{hyperref} % for hyperlinks
\usepackage{tocbibind} % includes the bibliography in the table of contents
\usepackage{amsmath} % for advanced math formatting
\usepackage{amsfonts} % for mathematical fonts
\usepackage{amssymb} % for mathematical symbols
\usepackage{lipsum} % generates filler text
\usepackage{fancyhdr}
\usepackage{amsthm} % for theorem environments
\usepackage{amsmath}
\usepackage[table]{xcolor} % for cell coloring
\usepackage{colortbl} % for cell coloring
\usepackage{graphicx} % for scaling the table
\usepackage{booktabs} % For professional looking tables
\usepackage[table]{xcolor} % For cell coloring
\usepackage[normalem]{ulem} % For underlining
\usepackage[document]{ragged2e}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{wrapfig}
\usepackage{circuitikz}
\usetikzlibrary{fit} % Add the missing TikZ library

\usetikzlibrary{arrows.meta,calc,decorations.markings,math,arrows.meta}

% Document geometry (page size, margins)
\geometry{a4paper, left=25mm, right=25mm, top=30mm, bottom=30mm}
% Custom page style for centered page numbers
\pagestyle{fancy}
\fancyhf{} % Clear all header and footer fields
\fancyhead[RE]{\leftmark} % 'LE' for Left Even pages - Chapter number and name
\fancyhead[RO]{Notes by Ali EL AZDI} % 'LO' for Left Odd pages - Custom message
\fancyfoot[CE,CO]{\thepage} % Centered page number in the footer for both even and odd pages

\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

% Document begins
\begin{document}


% Title Page
\begin{titlepage}
    \centering
    \vspace*{1cm}
    
    
    \vspace{0.5cm}
    \Huge
    Fundamentals of digital systems
    \vspace{10px}
    \newline
    \text{ \large Ali EL AZDI}


    \text{ \Large IC BA2 - Mirjana Stojilović}
    
    \vfill
    \large
    February 19, 2024

    
\end{titlepage}
\begin{center}
    \vspace*{1cm}
    \textbf{Introduction}
    \newline
    \paragraph[short]{}{This document is designed to offer a LaTeX-styled overview of the Fundamentals of Digital Systems course, emphasizing brevity and clarity. Should there be any inaccuracies or areas for improvement, please do not hesitate to reach out to me at ali.elazdi@epfl.ch for corrections. Hoping to provide an experience similar to the one provided by past generations of students in other subjects. Also, for the latest version of this pdf file, as the update on drive may take some time, you can find it on my github repository at the following link: \url{https://github.com/elazdi-al/FDS/blob/main/FDS.pdf}}
\end{center}


% Table of Contents
\tableofcontents

% List of Figures (Uncomment if needed)
% \listoffigures

% List of Tables (Uncomment if needed)
% \listoftables

\mainmatter% Chapter 1
\chapter{Number Systems}


% Section 1.1
\section{Digital Representations}
\begin{itemize}
    \item[] In a digital representation, a number is represented by an ordered n-tuple:
    \begin{itemize}
        \item[] The n-tuple is called a \textbf{digit vector}, each element is a \textbf{digit}
        \item[] The number of digits $n$ is called the precision of the representation. (careful! leftward indexing)
        
    
    \end{itemize}
\end{itemize}
\[ X  = (X _{n-1}, X _{n-1}, \ldots, X _{0}) \]
\begin{itemize}
    \item[] Each digit is given \textbf{a set of values} $D_{i}$ 
    (eg. For base 10 representation of numbers, $D_i = \{0,1,2, \dots, 9\}$)
    \item[] The \textbf{set size}, the maximum number of representable digit vectors is: $K = \prod_{i=0}^{n-1} |D_{i}|$
\end{itemize}



  
  




\subsection{(Non)Redundant Number Systems}
     A number system is nonredundant if each digit-vector represents a different integer

\subsection{Weighted Number Systems}
The rule of representation if a Weighted (Positional) Number Systems is as follows :
$$\;\displaystyle\sum_{i=0}^{n-1} X_{i}W_{i}$$ where $$W = (W_{n-1}, W_{n-2}, \dots, W_{0})$$

\subsection{Radix Systems}
When weights are in this format : 
\[
\begin{cases}
   $$W_{0} = 1 \\
    W_{i+1} = W_{i}R_{i} \;\; \text{with } 1 \leq i \leq n-1$$
    \end{cases} \]





Also written :
$W_{0} = 1, \; \prod_{j=0}^{i-1} R_{j}$

\subsection{Fixed and Mixed-Radix Number Systems}
\begin{itemize}
    \item[] In a \textbf{fixed-radix system}, all elements of the radix-vector have the same value \( r \) (\textit{the radix})
    \item[] The weight vector in a fixed-radix system is given by:
    \begin{equation*}
      W = \left( r^{n-1}, r^{n-2}, \ldots, r^2, r, 1 \right)
    \end{equation*}
    and the integer \( x \) becomes:
    \begin{equation*}
      x = \sum_{i=0}^{n-1} X_i \times r^i
    \end{equation*}
    \item[] In a \textbf{mixed-radix system}, the elements of the radix-vector differ
  \end{itemize}
  \subsection*{Example: Decimal Number System}
The decimal number system has the following characteristics:
\begin{itemize}
    \item[-] Radix \(r = 10\), it's a fixed-radix system.
\end{itemize}
The weight vector \(W\) is defined as:
\begin{equation*}
    W = \left(10^{n-1}, 10^{n-2}, \ldots, 10^2, 10, 1\right)
\end{equation*}
An integer \(x\) in this system is represented by:
\begin{equation*}
    x = \sum_{i=0}^{n-1} X_i \times 10^i
\end{equation*}
For example:
\begin{equation*}
    854703 = 8 \times 10^5 + 5 \times 10^4 + 4 \times 10^3 + 7 \times 10^2 + 0 \times 10^1 + 3 \times 10^0
\end{equation*}

\subsubsection{Examples of Fixed and Mixed radix systems}
\begin{description}
  \item[Fixed:] The base of number systems.
  \begin{itemize}
      \item Decimal – radix 10
      \item Binary – radix 2
      \item Octal – radix 8
      \item Hexadecimal – radix 16
  \end{itemize}
  \item[Mixed:] An example of a mixed radix representation, such as time:
  \begin{itemize}
      \item Radix-vector \(R = (24, 60, 60)\)
      \item Weight-vector \(W = (3600, 60, 1)\)
  \end{itemize}
\end{description}

\subsection{Canonical Number Systems}

\begin{itemize}
  \item[] In a \textbf{canonical number system}, the set of values for a digit \( D_i \) is with \( |D_i| = R_i \), the corresponding element of the radix vector
  \begin{equation*}
    D_i = \{0, 1, \ldots, R_i - 1\}
  \end{equation*}
  \item[] Canonical digit sets with fixed radix:
  \begin{itemize}
    \item Decimal: \{0, 1, \ldots, 9\}
    \item Binary: \{0, 1\}
    \item Hexadecimal: \{0, 1, 2, \ldots, 15\}
  \end{itemize}
  \item[] Range of values of \( x \) represented with \( n \) fixed-radix-\( r \) digits:
  \begin{equation*}
    0 \leq x \leq r^n - 1
  \end{equation*}
  A system with fixed positive radix r and a canonical set of digit values is called a radix-r conventional number system.
\end{itemize}
\newpage
\section{Binary/Octal/Hexadecimal to/from Decimal}
\section*{Conversion Table}
\begin{itemize}
  \item[] The hexadecimal system supplements 0-9 digits with the letters A-F.
  \vspace{-5px}
  \item[] \textit{Remark.} Programming languages often use the prefix 0x to denote a hexadecimal number.
\end{itemize}

% Define the color for the table cells
\definecolor{cellblue}{rgb}{0.88, 0.94, 0.97}
\definecolor{cellpink}{rgb}{0.96, 0.88, 0.89}
\definecolor{cellgreen}{rgb}{0.906, 1, 0.831}
\vspace{-20px}

\begin{table}[ht]
    \centering
    \caption{Conversion table up to 15.}
    \vspace{10px}
    \label{my-label}
    \begin{tabular}{@{}cccc@{}}
    \toprule
    \textbf{Decimal} & \textbf{Binary} & \textbf{Octal} & \textbf{Hexadecimal} \\ \midrule
     0 & \cellcolor{cellgreen}0000 & \cellcolor{cellblue}00 & \cellcolor{cellpink}0 \\
     1 & \cellcolor{cellgreen}0001 & \cellcolor{cellblue}01 & \cellcolor{cellpink}1 \\
     2 & \cellcolor{cellgreen}0010 & \cellcolor{cellblue}02 & \cellcolor{cellpink}2 \\
     3 & \cellcolor{cellgreen}0011 & \cellcolor{cellblue}03 & \cellcolor{cellpink}3 \\
     4 & \cellcolor{cellgreen}0100 & \cellcolor{cellblue}04 & \cellcolor{cellpink}4 \\
     5 & \cellcolor{cellgreen}0101 & \cellcolor{cellblue}05 & \cellcolor{cellpink}5 \\
     6 & \cellcolor{cellgreen}0110 & \cellcolor{cellblue}06 & \cellcolor{cellpink}6 \\
     7 & \cellcolor{cellgreen}0111 & \cellcolor{cellblue}07 & \cellcolor{cellpink}7 \\
     8 & \cellcolor{cellgreen}1000 & \cellcolor{cellblue}10 & \cellcolor{cellpink}8 \\
     9 & \cellcolor{cellgreen}1001 & \cellcolor{cellblue}11 & \cellcolor{cellpink}9 \\
    10 & \cellcolor{cellgreen}1010 & \cellcolor{cellblue}12 & \cellcolor{cellpink}A \\
    11 & \cellcolor{cellgreen}1011 & \cellcolor{cellblue}13 & \cellcolor{cellpink}B \\
    12 & \cellcolor{cellgreen}1100 & \cellcolor{cellblue}14 & \cellcolor{cellpink}C \\
    13 & \cellcolor{cellgreen}1101 & \cellcolor{cellblue}15 & \cellcolor{cellpink}D \\
    14 & \cellcolor{cellgreen}1110 & \cellcolor{cellblue}16 & \cellcolor{cellpink}E \\
    15 & \cellcolor{cellgreen}1111 & \cellcolor{cellblue}17 & \cellcolor{cellpink}F \\\bottomrule
    \end{tabular}
    \end{table}
    

    \subsection{Convertion examples}    
    \subsubsection*{Binary to Decimal:}

    
      To convert a binary number to decimal, multiply each bit by two raised to the power of its position number, starting from zero on the right.



    \begin{flalign*}
    & \text{Binary:}       & \underline{1} \underline{0} \underline{1} \underline{1} & \\
    & \text{Decimal:}      & 1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 1 \times 2^0 = 8 + 0 + 2 + 1 = 11 &
    \end{flalign*}
    
    \newpage

    \subsubsection*{Decimal to Binary:}

    Let's convert the decimal number \( 25_{10} \) to binary.

    \begin{tabular}{rclr}
    $25 \div 2$ & = & 12 & remainder 1 (LSB) \\
    $12 \div 2$ & = & 6  & remainder 0 \\
    $6 \div 2$  & = & 3  & remainder 0 \\
    $3 \div 2$  & = & 1  & remainder 1 \\
    $1 \div 2$  & = & 0  & remainder 1 (MSB) \\
    \end{tabular}

    \vspace*{10px}
    Thus, the binary representation of \( 25_{10} \) is \( 11001_2 \) (reading the remainders in reverse).
   

    \vspace*{10px}
    \textit{Personal Remark} The trick is always to try to answer the question, what's the biggest power of 2 I need to form the number?. For 157, the biggest power would be $2^{7} = 128$, then $128+64$ is greater than 157, $128 + 32$ is still greater than 157, $128 + 16 = 144$, and so on to obtain : $128+16+8+4+1=157$ which can be written as $2^7 + 2^4 + 2^3 + 2^2 + 2^0 = 157$. Written in binary as $ 10011101_{2} $

    \subsubsection*{Octal to Decimal:}
    
    Each octal digit is converted to decimal by multiplying it by eight raised to the power of its position number, starting from zero on the right.
    
    \begin{flalign*}
    & \text{Octal:}        & \underline{2} \underline{5} \underline{7} & \\
    & \text{Decimal:}      & 2 \times 8^2 + 5 \times 8^1 + 7 \times 8^0 = 128 + 40 + 7 = 175 &
    \end{flalign*}
    \subsubsection*{Decimal to Octal:}
 To convert the decimal number \(93_{10}\) to octal.
    
    \begin{tabular}{rclr}
    $93 \div 8$ & = & 11 & remainder 5 \\
    $11 \div 8$ & = & 1  & remainder 3 \\
    $1 \div 8$  & = & 0  & remainder 1 \\
    \end{tabular}
    
    \vspace*{10px}
    Thus, the octal representation of \(93_{10}\) is \(135_8\) (reading the remainders in reverse).
    
    \subsubsection*{Hexadecimal to Decimal:}

    To convert the hexadecimal number \( \text{1A3}_{16} \) to decimal.

    \begin{flalign*}
    & \text{Hexadecimal:}       & \underline{1} \underline{A} \underline{3} & \\
    & \text{Decimal:}           & 1 \times 16^2 + A \times 16^1 + 3 \times 16^0 & \\
    &                           & 1 \times 256 + 10 \times 16 + 3 \times 1 & \\
    &                           & 256 + 160 + 3 & \\
    &                           & 419 &
    \end{flalign*}

    Here, \( \text{A} \) in hexadecimal corresponds to \( 10 \) in decimal.



    


    
    \subsubsection*{Decimal to Hexadecimal:}
  
    To convert the decimal number \(291_{10}\) to hexadecimal.
    
    \begin{tabular}{rclr}
    $291 \div 16$ & = & 18 & remainder 3 \\
    $18 \div 16$  & = & 1  & remainder 2 \\
    $1 \div 16$   & = & 0  & remainder 1 \\
    \end{tabular}
    
    \vspace*{10px}
    Thus, the hexadecimal representation of \(291_{10}\) is \(123_{16}\) (reading the remainders in reverse).
    


    \section{Octal/Hexadecimal to/from Binary}
    \section*{Bit-Vector Representation Summary}

    \begin{itemize}
      \item Digit-vectors for binary, octal, and hexadecimal systems are represented using bit-vectors. In binary, 0 and 1 are directly represented as 0 and 1.
      \item In systems like octal or hexadecimal, a digit is a bit-vector of length \( k \), where \( k \) is the number of bits needed to represent the base.$$k=\log_{2}(r)$$
      with r the radix of the system (eg. 8 for octal convertion).
      \item For example, the hexadecimal digit \( B \) is represented as the bit-vector 1101 in binary. \textit{We obtain a length 4 bit-vector because the base is 16 and \( \log_{2}(16) = 4 \)}
    \end{itemize}

    \subsubsection*{Binary to Octal:}

    To convert a binary number to octal, group every three binary digits into a single octal digit, because \( k = \log_2 8 = 3 \).
    
    \begin{flalign*}
    & \text{Binary:}       & \underline{010}\,\underline{000}\,\underline{100}\,\underline{110} & \\
    & \text{Octal:}        & 2_8\,0_8\,4_8\,6_8 &
    \end{flalign*}
    
    \subsubsection*{Binary to Hexadecimal:}
    
    To convert a binary number to hexadecimal, group every four binary digits into a single hexadecimal digit, because \( k = \log_2 16 = 4 \).
    
    \begin{flalign*}
    & \text{Binary:}       & \underline{1011}\,\underline{1110}\,\underline{1010}\,\underline{1101} & \\
    & \text{Hexadecimal:}  & B_{16}\,E_{16}\,A_{16}\,D_{16} &
    \end{flalign*}
    


    \subsubsection*{Octal to Hexadecimal:}
    Convert the octal number to binary, then group the binary digits in sets of four and convert each group to its hexadecimal equivalent.
    
    \begin{flalign*}
    & \text{Octal:}        & \underline{2} \underline{5} \underline{7} & \\
    & \text{Binary:}       & 010 \, 101 \, 111 & \text{ (Octal to binary)} \\
    & \text{Binary grouped:} & \underline{0101} \, \underline{0111} & \\
    & \text{Hexadecimal:}  & 5 \, 7 & \text{ (Binary to hexadecimal)}
    \end{flalign*}    

    \section{Representation of
    Signed Integers}
    \subsection{Sign-Magnitude Representation (SM)}

    A signed integer \( x \) is represented by a pair \( (x_s, x_m) \), where \( x_s \) is the \textit{sign} and \( x_m \) is the \textit{magnitude} (positive integer).

    \begin{itemize}
        \item[] The sign (positive, negative) is represented by a the most significant bit (MSB) of the digit vector:
        \begin{itemize}
            \item[] \( 0 \rightarrow \) positive
            \item[] \( 1 \rightarrow \) negative
        \end{itemize}
        \item[] The magnitude can be represented as any positive integer. In a conventional radix-\( r \) system, the range of \( n \)-digit magnitude is:
        \[ 0 \leq x_m \leq r^n - 1 \]
    \end{itemize}

    \begin{itemize}
      \item[-] Examples:
      \begin{align*}
          01010101_2 &= +85_{10} \\
          01111111_2 &= +127_{10} \\
          00000000_2 &= +0_{10} \\
          11010101_2 &= -85_{10} \\
          11111111_2 &= -127_{10} \\
          10000000_2 &= -0_{10} \\
      \end{align*}
  \end{itemize}
  \newpage
  Note: The Sign-and-Magnitude representation is considered a redundant system because both \( 00000000_2 \) and \( 10000000_2 \) represent zero.

  \begin{itemize}
    \item[] \textit{SM} consists of an equal number of positive and negative integers.
    \item[] An \( n \)-bit integer in sign-and-magnitude lies within the range \textit{(because of 0's double representation and that MSB is used for the sign)}: 
    $$ [-\left(2^{n-1} - 1\right), +\left(2^{n-1} - 1\right)] $$ 
    \item[] Main disadvantage of SM: complex digital circuits for arithmetic operations (addition, subtraction, etc.).
\end{itemize}

\section{True-and-Complement (TC)}

\subsection{Mapping}
\begin{itemize}
    \item[] A signed integer \( x \) is represented by a positive integer \( x_R \), \( C \) is a positive integer called the \textit{complementation constant}.
    \[ x_R \equiv x \mod C \]
    
    \item[] For \( |x| < C \), by the definition of the modulo function, we have:
    \[
    x_R = 
    \begin{cases} 
    x & \text{if } x \geq 0 \quad \text{(True form)} \\
    C - |x| = C + x & \text{if } x < 0 \quad \text{(Complement form)}
    \end{cases}
    \]
\end{itemize}

\subsection{Unambiguous Representation}
\begin{itemize}
    \item[] To have an unambiguous representation, the two regions should not overlap, translating to the condition:
    \[ \max |x| < \frac{C}{2} \]
\end{itemize}


\subsection{Converse Mapping}
\begin{itemize}
    \item[] Converse mapping:
    \[
    x = 
    \begin{cases} 
    x_R & \text{if } x_R < \frac{C}{2} \quad \text{(Positive values)} \\
    x_R - C & \text{if } x_R > \frac{C}{2} \quad \text{(Negative values)}
    \end{cases}
    \]
    \item[] When \( x_R = \frac{C}{2} \), it is usually assigned to \( x = -\frac{C}{2} \).
    \item[] Asymmetrical representation simplifies sign detection.

\end{itemize}

\section{Two's Complement System}
This is the True-and-Compelement system with \( C = 2^n \), where \( n \) is the number of bits used to represent the integer.
\begin{itemize}
    \item[] Range is asymmetrical:
    \[ -2^{n-1} \leq x \leq 2^{n-1} - 1\]
    \item[] The representation of zero is unique.
\end{itemize}


\subsection{Sign Detection in Two's Complement System}

\begin{itemize}
  \item[] Since $|x| < C/2$ and assuming the sign is 0 for positive and 1 for negative numbers:
\end{itemize}

\[
\text{sign}(x) = 
\begin{cases} 
0 & \text{if } x_R < C/2 \\
1 & \text{if } x_R \geq C/2
\end{cases}
\]

\begin{itemize}
  \item[] Therefore, the sign is determined from the most-significant bit:
\end{itemize}

\[
\text{sign}(x) = 
\begin{cases} 
0 & \text{if } x_{n-1} = 0 \\
1 & \text{if } x_{n-1} = 1
\end{cases}
\quad \text{equivalent to} \quad \text{sign}(x) = x_{n-1}
\]
\subsection{Mapping from Bit-Vectors to Values}
The value of an integer represented by a bit-vector $b_{n-1}b_{n-2}\ldots b_1b_0$ can be universally expressed as:
\[
\text{Value} = (-2^{n-1} \cdot b_{n-1}) + \sum_{i=0}^{n-2} b_i \cdot 2^i
\]
where $b_{n-1}$ is the MSB (sign bit) and is $0$ for non-negative numbers and $1$ for negative numbers.

\subsubsection{Examples}
  \begin{itemize}
      \item[] $X = 011011_2 = 0 \cdot 2^5 + 1 \cdot 2^4 + 1 \cdot 2^3 + 0 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 = 16 + 8 + 2 + 1 = 27_{10}$
      \item[] $X = 11011_2 = -1 \cdot 2^4 + 1 \cdot 2^3 + 0 \cdot 2^2 + 1 \cdot 2^1 + 1 \cdot 2^0 = -16 + 8 + 2 + 1 = -5_{10}$
      \item[] $X = 10000000_2 = -1 \cdot 2^7 = -128_{10}$
      \item[] $X = 10000011_2 = -1 \cdot 2^7 + 1 \cdot 2^1 + 1 \cdot 2^0 = -128 + 2 + 1 = -125_{10}$
  \end{itemize}
  
  \subsection{Change of Sign in Two's Complement System}


  The two's complement system represents negative numbers by inverting the bits of their positive counterparts and adding one. This process is equivalent to subtracting the number from $2^n$.
  
  For an $n$-bit number $x$:
  \[
  z = -x = (\sim x) + 1 = C - x_R
  \]
  where $(\sim x)$ is the bitwise NOT of $x$ and $x_R$ is the decimal representation of $x$.
  

  


  \subsection*{Examples}
  Converting $+17$ to $-17$:
  \[
  \begin{aligned}
  +17_{10} &= 00010001_2 \\
  -17_{10} &= \overline{00010001_2} + 1 = 11101111_2 \\
  2^8 - 17 &= 256 - 17 = 239 = 11101111_2
  \end{aligned}
  \]
  
  Converting $-99$ to $+99$:
  \[
  \begin{aligned}
  -99_{10} &= 10011101_2 \\
  +99_{10} &= \overline{10011101_2} + 1 = 01100011_2 && (TC) \\
  2^8 - 99 &= 256 - 99 = 157 = 01100011_2 \; (Substracting \; 99 \; from \; 256)
  \end{aligned}
  \]

  \section{Range Extension
  and Arithmetic Shifts}
\subsection{Range Extension}



\begin{itemize}
  \item[] Performed when a value \( x \) represented by a digit-vector of \( n \) bits needs to be represented by a digit-vector of \( m \) bits, where \( m > n \).
  \item[] \( x \) is equal to \( z \) with
  \begin{align*}
      X &= (X_{n-1}, X_{n-2}, \ldots, X_1, X_0) \\
      Z &= (Z_{m-1}, Z_{m-2}, \ldots, Z_1, Z_0)
  \end{align*}
\end{itemize}

{\small \section[]{Range Extension Algorithm in SM}}

\begin{itemize}
    \item[] In sign-and-magnitude system, the range-extension algorithm is defined as:
    \begin{align*}
        z_s &= x_s \text{ (sign bit)} \\
        Z_i &= 0 \quad \text{for } i = m - 1, m - 2, \ldots, n \\
        Z_i &= X_i \quad \text{for } i = n - 1, \ldots, 0
    \end{align*}
    \item[] Example: Consider \( X = 11010101_2 = -45_{10} \) and \( X = 100101101_2 = -45_{10} \).
    \item[] The algorithm extends the range of \( X \) by adding zeros to the left of the most significant bit, preserving the sign bit.
\end{itemize}


\subsection[]{Arithmetic Shifts}


\begin{itemize}
    \item[] Two elementary transformations often used in arithmetic operations are scaling (multiplying and dividing) by the radix.
    \item[] In the conventional radix-2 number system for integers:
    \begin{itemize}
        \item[] Left arithmetic shift: multiplication by 2, expressed as \( z = 2x \).
        \item[] Right arithmetic shift: division by 2, expressed as \( z = 2^{-1}x - \varepsilon \), where \( |\varepsilon| < 1 \) and the value of \( \varepsilon \) is such that it makes \( z \) an integer. \textit{The value of \( \varepsilon \) is the remainder of the division}.
        
    \end{itemize}
\end{itemize}

\subsection{Left Arithmetic Shift in Sign-and-Magnitude System}

\begin{itemize}
    \item[] Algorithm (assuming the overflow does not occur):
    \begin{align*}
        z_s &= x_s \text{ (sign bit retained)} \\
        Z_{i+1} &= X_i, \quad \text{for } i = 0, \ldots, n-2 \\
        Z_0 &= 0 \text{ (insert zero at the least significant bit)}
    \end{align*}
    \subsubsection*{Example:}
    \begin{itemize}
        \item[] Given \( X = 100101101_2 = -45_{10} \),
        \item[] The left arithmetic shift \( SL(X) \) would be \( 101011010_2 = -90_{10} \).
    \end{itemize}
\end{itemize}

\subsection{Right Arithmetic Shift in Sign-and-Magnitude System}

\begin{itemize}
    \item[] Algorithm:
    \begin{align*}
        z_s &= x_s \text{ (sign bit retained)} \\
        Z_{i-1} &= X_i, \quad \text{for } i = 1, \ldots, n - 1 \\
        Z_{n-1} &= 0 \text{ (insert zero at the most significant bit)}
    \end{align*}
    \item[] Example:
    \begin{itemize}
        \item[] Given \( X = 100101101_2 = -45_{10} \),
        \item[] The right arithmetic shift \( SR(X) \) would be \( 100010110_2 = -22_{10} \).
    \end{itemize}
\end{itemize}

\newpage
\subsection{Left Arithmetic Shift in Two's Complement System}

\begin{itemize}
    \item[] Algorithm (assuming that overflow does not occur):
    \begin{align*}
        Z_{i+1} &= X_{i}, \quad \text{for } i = 0, \ldots, n-2 \\
        Z_{0} &= 0 \text{ (insert zero at the least significant bit)}
    \end{align*}
    \item[] Examples:
    \begin{itemize}
        \item[] Given \( X = 00110101_2 = 13_{10} \),
        \item[] The left arithmetic shift \( SL(X) \) is \( 01101010_2 = 26_{10} \).
        \item[] Given \( Y = 11010101_2 = -11_{10} \),
        \item[] The left arithmetic shift \( SL(Y) \) is \( 10101010_2 = -22_{10} \).
    \end{itemize}
\end{itemize}



\subsection{Right Arithmetic Shift in Two's Complement System}


\begin{itemize}
    \item[] Algorithm (assuming that overflow does not occur):
    \begin{align*}
        Z_{n-1} &= X_{n-1} \\
        Z_{i-1} &= X_i, \quad \text{for } i = 1, \ldots, n-1
    \end{align*}
    The most significant bit (MSB) is duplicated to keep the sign of the number the same.
    \item[] Examples:
    \begin{itemize}
        \item[] For $X = 001101_2 = 13_{10}$, the right arithmetic shift is $SR(X) = 000110_2 = 6_{10}$.
        \item[] For $Y = 110101_2 = -11_{10}$ (in two's complement), the right arithmetic shift is $SR(Y) = 111010_2 = -6_{10}$.
    \end{itemize}
\end{itemize}


\section{Hamming Weight and Distance}


\subsection{Hamming Weight (HW)}
\begin{itemize}
    \item[] The Hamming weight of a binary sequence is the number of symbols that are equal to one (1s).
    \item[] For example, the Hamming weight of \( 11010101 \) is 5, as there are five 1s in the bit sequence.
\end{itemize}

\subsection{Hamming Distance (HD)}
\begin{itemize}
    \item[] The Hamming distance between two binary sequences of equal length is the number of positions at which the corresponding symbols are different.
    \item[] For example, the Hamming distance between \( 11010101 \) and \( 01000111 \) is 3, as they differ in three positions.
\end{itemize}


\section{Binary Coded Decimal (BCD)}

Binary Coded Decimal (BCD) represents decimal numbers where each decimal digit is encoded as a four-bit binary number. This method allows decimal numbers to be represented in a format that is easy for digital systems to process.

\subsection{BCD Encoding}

\begin{itemize}
    \item In BCD, each of the decimal digits \(0\) through \(9\) is represented by a four-bit binary number, ranging from \(0000\) to \(1001\).
    \item Binary values from \(1010_2\)($10_{10}$) to \(1111_{2}\)($15_{10}$) are not used in standard BCD encoding.
    \item For example, 25 is represented as \(\underline{{0010 \; 0101}}_{2}\).
\end{itemize}

\subsection{Conversion Algorithms}

\subsubsection{From BCD to Decimal}

To convert a BCD-encoded number to its decimal representation:

\begin{verbatim}
1. Initialize i to the highest index of BCD digits (n-1), D to 0.
2. While i is greater than or equal to 0:
   a. Multiply D by 10.
   b. Add the decimal value of the BCD digit at index i to D.
   c. Decrement i.
\end{verbatim}

\subsubsection{From Decimal to BCD}

To convert a decimal number to its BCD representation:

\begin{verbatim}
1. Initialize i to 0, D to the decimal number.
2. While D is not equal to 0:
   a. Calculate D mod 10 and store it as the current BCD digit.
   b. Divide D by 10.
   c. Increment i.
\end{verbatim}

\newpage
\section{Gray Code Conversion Algorithm}
\begin{itemize}
    \item[] \textbf{Rule for Conversion}:
    \begin{itemize}
        \item[] For bit \( i \) in the Gray code, look at bits \( i \) and \( i+1 \) in the binary code (bit \( n \) in binary is zero if \( i+1 = n \)).
        \item[] If bits \( i \) and \( i+1 \) in the binary are the same, bit \( i \) in the Gray code is 0.
        \item[] If they are different, bit \( i \) in the Gray code is 1.
    \end{itemize}
\end{itemize}

\subsection{Example}
\text{To convert the binary number 1011 to Gray code.}

\begin{enumerate}
    \item[] let: \(\underline{1011}_{2} = b_3b_2b_1b_0 \).
    \item[] Apply the conversion rule:
    \begin{itemize}
        \item[] \( g_3 = b_3 \) since there is no \( b_4 \) (assume \( b_4 = 0 \)).
        \item[] \( g_2 = b_3 \oplus b_2 \).
        \item[] \( g_1 = b_2 \oplus b_1 \).
        \item[] \( g_0 = b_1 \oplus b_0 \).
    \end{itemize}
    \item[] Calculate the Gray code bits:
    \begin{itemize}
        \item[] \( g_3 = 1 \oplus 0 = 1 \text{\; as \( b_{4} \) doesn't exist and is thus a 0} \).
        \item[] \( g_2 = 1 \oplus 0 = 1 \).
        \item[] \( g_1 = 0 \oplus 1 = 1 \).
        \item[] \( g_0 = 1 \oplus 1 = 0 \).
    \end{itemize}
    \item[] The Gray code is: \( g_3g_2g_1g_0 = \underline{1110}_{\text{gray code}} \).
\end{enumerate}


\chapter{Number Systems (Part II)}

\section{Addition and Subtraction
of Unsigned Integers}
\textit{Personal Remark. In case this is not clear, this video explains it pretty good:\newline \url{https://www.youtube.com/watch?v=sJXTo3EZoxM}}
\subsection{Addition of Binary Numbers}

To add binary numbers, follow these rules:
\begin{itemize}
    \item[] \(0 + 0 = 0\)
    \item[] \(0 + 1 = 1\)
    \item[] \(1 + 0 = 1\)
    \item[] \(1 + 1 = 10\) (0 and carry 1 to the next higher bit)
    \item[] \(1 + 1 + 1 = 11\) (1 and carry 1 to the next higher bit)
\end{itemize}

\subsection*{Example:}

Adding \(1101_2\) and \(1011_2\):

\[
\begin{array}{cccccc}
& 1 & 1 & 1 & 0 & \text{(Carry)} \\
\hline
 & 1 & 1 & 0 & 1 & \\
+ & 1 & 0 & 1 & 1 & \\
\hline
1 & 1 & 0 & 0 & 0 & \\
\end{array}
\]


\newpage
\subsection{Subtracting Two Binary Numbers}
Works exactly like subtracting decimal numbers, but with a borrow of 2 instead of 10.

The rules for binary subtraction include:
\begin{itemize}
    \item[] \(0 - 0 = 0\)
    \item[] \(1 - 0 = 1\)
    \item[] \(1 - 1 = 0\)
    \item[] \(0 - 1 = 1\) (with a borrow from the next higher bit)
\end{itemize}

\subsection*{Example:}

Subtracting \(1000_2\) from \(1101_2\):

\[
\begin{array}{cccccc}
 & 1 & 1 & 0 & 1 & \\
- & 1 & 0 & 0 & 0 & \\
\hline
 & 0 & 1 & 0 & 1 & \\
\end{array}
\]


Therefore, the difference between $1101_2$ and $1011_2$ is $0010_2$.

\section{\large Overflow and Underflow in Unsigned Binary Arithmetic}

\subsection{Overflow}

Overflow in unsigned binary arithmetic occurs when the sum of two numbers exceeds the maximum value that can be represented by the given number of bits. For an \(n\)-bit unsigned number, the maximum value that can be represented is \(2^n - 1\). If the result of an addition is greater than this maximum value, the system experiences overflow, leading to an incorrect result.

\textbf{Example:} Consider adding two 4-bit unsigned numbers \(1111_2\) and \(0001_2\):

\[
\begin{array}{cccccc}
 & 1 & 1 & 1 & 1 & \\
+ & 0 & 0 & 0 & 1 & \\
\hline
1 & 0 & 0 & 0 & 0 & \\
\end{array}
\]

The result \(10000_2\) is a 5-bit number, but only the 4 least significant bits \(0000_2\) are kept in a 4-bit system, leading to overflow.
\newpage
\subsection{Underflow}

Underflow in unsigned binary arithmetic occurs when the result of a subtraction is less than 0, which is not representable in unsigned arithmetic. Since unsigned numbers cannot represent negative values, any operation that would result in a negative value causes underflow.

\textbf{Example:} Consider subtracting a larger 4-bit unsigned number \(1010_2\) from a smaller one \(0100_2\):

\[
\begin{array}{cccccc}
 & 0 & 1 & 0 & 0 & \\
- & 1 & 0 & 1 & 0 & \\
\hline
\end{array}\]
\vspace{-15px}
\begin{align*}
    \text{underflow}
\end{align*} 

Since the result would be negative, which cannot be represented in unsigned arithmetic, this situation is considered underflow.


\section{Two’s Complement
Addition and Subtraction}
\subsection*{Graphical Representation}

\begin{wrapfigure}{r}{0.5\textwidth} % This line sets the wrapfigure environment to place the figure on the right side and occupy half the text width
  \centering
  \includegraphics[width=0.41\textwidth]{circle-twoscomplement.png} % Replace 'path_to_image.png' with the actual path to your image file
  \caption{Circular representation of two's complement}
\end{wrapfigure}

In two's complement arithmetic, a circular graphical representation can be used to illustrate the addition and subtraction of numbers:
\begin{itemize}
  \item[-] Moving \textbf{clockwise} from 0 represents the \textit{addition} of positive numbers.
  \item[-] Moving \textbf{counterclockwise} represents the \textit{subtraction} of positive numbers.
  \item[-] Crossing the line where the sign changes indicates a \textit{change of sign} from positive to negative or vice versa.
  \item[] \textbf{Examples:}
    \begin{itemize}
        \item[] The addition of two positive numbers, such as \(2 + 3\), is shown by moving clockwise from 0 to 2 and then moving 3 more steps clockwise, resulting in 5.
        \item[] The subtraction of a smaller number from a larger number, such as \(5 - 3\), is shown by moving clockwise from 0 to 5 and then moving 3 steps counterclockwise, resulting in 2.  
    \end{itemize}
\end{itemize}

\subsection{Addition and Subtraction}
\subsection{Addition}
Given two \(n\)-bit numbers \(A\) and \(B\), their sum in two's complement arithmetic is obtained by directly adding them together as binary numbers:
\begin{equation}
    \text{Sum} = A + B
\end{equation}
If there is an overflow, i.e., a carry out of the most significant bit (MSB), it is discarded. The result is also represented in \(n\) bits.

\subsection{Subtraction}
To subtract one \(n\)-bit number \(B\) from another \(A\) using two's complement arithmetic, convert \(B\) to its two's complement and then add it to \(A\):
\begin{enumerate}
    \item Find the two's complement of \(B\), denoted as \(\bar{B}\), by inverting all the bits of \(B\) and adding \(1\).
    \item Add \(A\) to the two's complement of \(B\):
    \begin{equation}
        \text{Difference} = A + \bar{B}
    \end{equation}
\end{enumerate}
As with addition, discard any overflow from the MSB.


\section{Binary Multiplication}

\begin{proof}[Proof]
    Let $X$ and $Y$ be two numbers, then their product can be represented as:
    \begin{align*}
    X \cdot Y &= X \cdot \left( -Y_{n-1} \cdot 2^{n-1} + X \sum_{i=0}^{n-2} Y_i \cdot 2^i \right) \\
    &= -X \cdot Y_{n-1} \cdot 2^{n-1} + X \sum_{i=0}^{n-2} Y_i \cdot 2^i \\
    &= -Y_{n-1} \cdot X \cdot 2^{n-1} + Y_{n-2} \cdot X \cdot 2^{n-2} + \ldots + Y_2 \cdot X \cdot 2^2 + Y_1 \cdot X \cdot 2^1 + Y_0 \cdot X \cdot 2^0
    \end{align*}
\end{proof}
    
  

\newpage
Binary multiplication operates similarly to decimal multiplication but is performed bit by bit. Here is a clearer example illustrating the multiplication of two binary numbers:

\begin{align*}
    & \text{Multiplicand} & 1101 & \quad & \text{(This is the number to be multiplied)}\\
    & \text{Multiplier} & \times \; 0011 & & \text{(This number multiplies the multiplicand)}\\
    \cline{2-4}
    && 1101 & & \text{(Multiply by 1, the least significant bit of the multiplier)}\\
    &+& 11010 & & \text{(Multiply by 1, add one zero to the right, (left shift, $<<1$))}\\
    &+& 000000 & & \text{(Multiply by 0, add two zeros to the right, (left shift, $<<2$))}\\
    &+& 0000000 & & \text{(Multiply by 0, add three zeros to the right, (left shift, $<<3$))}\\
    \cline{2-4}
    && 100111 & & \text{(Sum of the partial products)}
\end{align*}




\chapter{Number Systems (Part III)}
    \section{Fixed-Point
    Number Representation}  

Let \(x\) be an integer :
$x  = x_{int} + x{fr}$, with $x_{int}$ the integer part and $x_{fr}$ the fractional part.

Let \( X \) be a digit-vector:

\[ X = (X_{m-1} X_{m-2} \dots X_1 X_0 \; . \;  X_{-1} X_{-2} \dots X_{-f}) \]

where
\begin{itemize}
  \item[] \( X_{m-1} \) to \( X_0 \) represent the integer component
  \item[] \( X_{-1} \) to \( X_{-f} \) represent the fractional component
  \item[] The dot (.) represents the radix point (assumed to be fixed)
\end{itemize}
\vskip 0.5cm
For unsigned numbers:
\[ x = \sum_{i=-f}^{m-1} X_i \cdot 2^i \]

\vskip 0.5cm
For signed numbers in two's complement:

\[ x = -X_{m-1} \cdot 2^{m-1} + \sum_{i=-f}^{m-2} X_i \cdot 2^i \]

\newpage
    \subsection{Examples of Fixed-Point Numbers}
    \subsubsection{ Decimal Numbers}

    \begin{itemize}
        \item[] Decimal number system with \( m = 5, f = 5 \)
        \item[] Example decimal digit vector
        \[
        x = (10077.01690)
        \]
        \[
        x = 1 \cdot 10^4 + 7 \cdot 10^1 + 7 \cdot 10^0 + 1 \cdot 10^{-2} + 6 \cdot 10^{-3} + 9 \cdot 10^{-4}
        \]
        \[
        = 10000 + 70 + 7 + 0.01 + 0.006 + 0.0009
        \]
        \[
        = 10077.0169
        \]
        \item[] Most negative (min):
        \[
        x_{\text{min}} = -99999.99999 = \frac{-9999999999}{10^5}
        \]
        \item[] Largest number (max, positive):
        \[
        x_{\text{max}} = +99999.99999 = \frac{+9999999999}{10^5}
        \]
    \end{itemize}

    \subsubsection{Unsigned Binary Numbers}

    \begin{itemize}
        \item[] Unsigned with \( m = 3, f = 4 \)
        \item[] Example binary digit vector
        \[
            X = 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 + 0 \cdot 2^{-1} + 1 \cdot 2^{-2} + 1 \cdot 2^{-3} + 1 \cdot 2^{-4} = 5.4375 \]

        \item[] Smallest number (min):
        \[
        x_{\text{min}} = 000.0000_2 = 0
        \]
        \item[] Largest number (max):
        \[
        x_{\text{max}} = 111.1111_2 = 7 + \frac{15}{16} = 7,9375
        \]
    \end{itemize}
    
    \subsubsection{Sign-and-Magnitude Binary Numbers}
    \begin{itemize}
        \item[] Sign-and-magnitude with \( m = 5, f = 3 \)
        \item[] Example binary digit vector
        \[
            X = (-1)^{1} \cdot (1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 + 1 \cdot 2^{-1} + 1 \cdot 2^{-2} + 0 \cdot 2^{-3}) = -5.75
        \]
        \item[] Most negative number (min):
        \[
            x_{\text{min}} = 1 1111.111_2 = -15 + \frac{7}{8} = -15.875
        \]
        \item[] Largest number (max, positive):
        \[
            x_{\text{max}} = 0 1111.111_2 = 15 + \frac{7}{8} = 15.875
        \]
    \end{itemize}
      
    \section{Concepts of
    Finite Precision Math}
    \subsection{Precision}
    Let \( X \) be a digit-vector:
    \[ X = (X_{m-1} X_{m-2} \dots X_1 X_0 \; . \;  X_{-1} X_{-2} \dots X_{-f}) \]

    Precision is the maximum number of non zero bits.
    $$Precision(x) = m + f$$ with \(m\) the number of bits for the integer part and \(f\) the number of bits for the fractional part.

    \subsection{Resolution}
    Resolution is the smallest non-zero number that can be represented.

    $$Resolution(x) = 2^{-f}$$


    \subsection{Range}
    The range of a fixed-point number is the difference between the largest and smallest numbers that can be represented.

    \[Range(x) = x_{\text{max}} - x_{\text{min}}\]
    \newblock
    \newline
    In two's complement, the range is given by:
    \[ Range(x) = \displaystyle\sum_{i=-f}^{m-2} 2^i - \left( -2^{m-1} \right)\]

    \subsection{Accuracy}
    Accuracy is the maximum difference between a real value and the represented value.

    $$Accuracy(x) = \frac{Resolution(x)}{2}$$

    \subsection{Dynamic Range}
    The dynamic range is the ratio of the largest and the smallest positive number that can be represented.

    $$Dynamic \; Range(x) = \frac{x_{\text{max}}}{x_{\text{min}}}$$

    \textit{In two's complement :}
    $$Dynamic \; Range(x) = \frac{2^{m-1}}{2^{-f}} = 2^{m-1+f}$$

    \section{Floating-Point Number Representation}
    \textit{Personal Remark. Please take the time to really understand this part. It is crucial for the understanding of the rest of the course. Take some time to understand the vocabulary and its meaning.}\newline
    \vskip 0.5cm
    A real number that is exactly representable in a computer is called a \textbf{floating-point number}. 
    \subsection{Significand, Base, Exponent}
    A floating-point number consits of a \textbf{significand} (or mantissa), a \textbf{base} (or radix), and an \textbf{exponent}.
\begin{itemize}
  \item[] the signed \textit{significand} (also called \textit{mantissa}) \( M^* \)
  \item[] the signed \textit{exponent} \( E \)
\end{itemize}

where \( b \) is a constant called the \textit{base}

\[ x = M^* \times b^E \]

This reminds us of the usual scientific notation, base 10:
\begin{itemize}
  \item[] \( +35200 = +3.52 \times 10^4 \) (Coefficient)
  \item[] \( -0.099 = -9.9 \times 10^{-2} \) (Exponent)
\end{itemize}

\subsection{Benefits }
\begin{enumerate}
    \item \textit{Consider 32-bit two's complement signed integers}
    
    The dynamic range for a 32-bit two's complement signed integer can be expressed as:
    \begin{equation*}
    \text{Dynamic Range}_1 (x) = \frac{\lvert x \rvert_{\text{max}}}{\lvert x_{\text{positive, nonzero}} \rvert_{\text{min}}} = \frac{\lvert -2^{32-1} \rvert}{2^0} = 2^{31} \approx 2 \cdot 10^9
    \end{equation*}
    
    \item \textit{Consider 32-bit floating-point number, with 24-bits significand and 8-bit exponent in two's complement}
       
   {$\text{Dynamic Range}_2 (x) = \frac{\lvert x \rvert_{\text{max}}}{\lvert x_{\text{positive, nonzero}} \rvert_{\text{min}}}$ $$= \frac{(2^{23} - 1) \cdot 2^{(2^{8-1}) - 1}}{2^{-128}} = \frac{(2^{23} - 1) \cdot 2^{127}}{2^{-128}} = (2^{23} - 1) \cdot 2^{255} \approx 5 \cdot 10^{83}$$}

    
    \item \textit{Dynamic range increase}
    
    Comparing the two dynamic ranges:
    \begin{equation*}
    \frac{\text{Dynamic Range}_2 (x)}{\text{Dynamic Range}_1 (x)} \approx 10^{74}
    \end{equation*}
\end{enumerate}
\newpage


\begin{enumerate}

        \item \textit{Consider a fixed-point number with 8 fractional bits}
        \begin{equation*}
            \text{Resolution}_1(x) = 2^{-8}
        \end{equation*}
    
        \item \textit{Consider 32-bit floating-point number, with 24-bits significand in sign-and-magnitude and 8-bit exponent in two's complement}
        \begin{equation*}
            \text{Resolution}_2(x) = 2^0 \cdot 2^{-2(8-1)} = 2^{-2^7} = 2^{-128}
        \end{equation*}
    
        \item \textit{Improved resolution}
        \begin{equation*}
            \frac{\text{Resolution}_2(x)}{\text{Resolution}_1(x)} = \frac{2^{-128}}{2^{-8}} = 2^{-120}
        \end{equation*}
    \end{enumerate}


    
    \subsection{Representation}
    \begin{itemize}
        \item[] We will be focusing on the following digit-vector:
        \[
        X = (\underbrace{S}_{\text{\color{purple}Sign}}E_{m-1}E_{m-2}\dots E_1E_0\underbrace{M_{n-1}M_{n-2}\dots M_0}_{\text{\color{purple}Magnitude}})
        \]


    The floating-point representation becomes
    \[
    x = (-1)^s \times M \times b^E
    \]
    where \( s \in \{0, 1\} \) is the \textbf{sign}, and \( M \) is the \textbf{magnitude} of the signed significant
    \vskip 0.5cm
    \textbf{In the rest of the lecture, we assume significand is represented in sign-and-magnitude.}
    \end{itemize}


    \subsubsection[short]{Normalization}
    The goal of normalization is to represent the number such that the magnitude (\(M\)) is within the range \(1 \leq M < 2\). This means that the leading digit before the binary point is always 1. Here are examples to demonstrate this process:

    \begin{itemize}
        \item[] \textbf{Positive Example}:
        \begin{itemize}
            \item[] Given: \( +1010.1000_2 \)
            \item[] Normalize: \( +1.1010_2 \times 2^3 \)
            \item[] Decimal Conversion: \( 1.3125 \times 8 = 10.5 \)
            \item[] Explanation: The binary number \(1010.1000_2\) is normalized by shifting the binary point such that the first digit is 1, and adjusting the exponent (\(2^3\)) accordingly. The equivalent decimal number is \(10.5\).
        \end{itemize}
    \newpage
        \item[] \textbf{Negative Example}:
        \begin{itemize}
            \item[] Given: \( -(0.00000011)_2 \)
            \item[] Normalize: \( -1.1_2 \times 2^{-7} \)
            \item[] Decimal Conversion: \( -(1.5)_{10} \times 2^{-7} = -0.01171875 \)
            \item[] Explanation: The binary number \(0.00000011_2\) is normalized by shifting the binary point to get a leading 1, and adjusting the exponent (\(2^{-7}\)) to reflect the shift. The equivalent decimal number is \(-0.01171875\).
        \end{itemize}
    \end{itemize}
    
    \subsubsection{Why Normalize?}
    
    Normalization removes redundancy from floating-point representation, making it unique. Consider these examples to understand the redundancy in non-normalized representations:

        \[
            \begin{aligned}
            & + (1010)_2 \times 2^{-2} = 10 \times 2^{-2} = 2.5; \\
            & + (1.01)_2 \times 2^{1} = 1.25 \times 2^{1} = 2.5; \\
            & + (0101)_2 \times 2^{-1} = 5 \times 2^{-1}  = 2.5; \\
            \end{aligned}
            \]

    
    In these cases, different representations lead to the same decimal value, illustrating redundancy. Normalization ensures that each number has a unique floating-point representation. 
    \vskip 0.5cm
    \textbf{Conclusion}: Floating-point representation is \textcolor{red}{redundant unless it is normalized}. By normalizing, we ensure a unique and efficient representation for computational purposes.
\vskip 0.5cm
    In normalized floating-point representation, the leading digit is always 1 and is omitted as a hidden bit to save space, with the remaining digits representing the fraction part of the significand :
    \begin{itemize}
        \item[] \( +(101.001)_2 \times 2^{-4} \Rightarrow +(1.01001)_2 \times 2^{-2} \Rightarrow +(.01001)_2 \times 2^{-2} \)
    \end{itemize}




\newpage
\subsection{Biased Representation}

Given a binary number with $n$ bits, the value of the biased representation can be calculated as follows:

\[
x = \sum_{i=0}^{n-1} X_i \cdot 2^i - B
\]

Where $X_i$ represents the $i^{th}$ bit of the binary number (starting from 0 for the least significant bit), and $B$ is the bias, which is calculated by:

\[
B = 2^{(n-1)} - 1
\]


The exponent thus becomes : 
\[ e = \sum_{i=0}^{n-1} E_i \cdot 2^i - (2^{(n-1)} - 1) \]

For instance, with a 3-bit binary number, the bias $B$ is $2^{(3-1)} - 1 = 3$. Therefore, the biased representation maps binary numbers to the integer range from $-B$ to $2^n - 1 - B$.

\subsubsection{Example}

For a 3-bit binary number, the biased representations would be:

\begin{center}
\begin{tabular}{ccc}
\textbf{Decimal} & \textbf{Binary} & \textbf{Biased Decimal} \\
\hline
7 & 111 & 4 \\
6 & 110 & 3 \\
5 & 101 & 2 \\
4 & 100 & 1 \\
3 & 011 & 0 \\
2 & 010 & -1 \\
1 & 001 & -2 \\
0 & 000 & -3 \\
\end{tabular}
\end{center}

Note that the minimum exponent in the biased representation is zero so that the representation of FP zero value is all zeros (zero sign, exponent, and mantissa).

\newpage
\section*{Summary of the Floating-Point Representation}
Let the binary vector : 
\[ X = (S E_{m-1}E_{m-2}\dots E_1E_0 \; . \; M_{n-1}M_{n-2}\dots M_0) \]

\begin{itemize}
    \item[] $(m)$-bit exponent
    \begin{itemize}
      \item[-] Biased, $B = 2^{m-1} - 1$
    \end{itemize}
    \item[] $(n + 1)$-bit significand
    \begin{itemize}
      \item[-] Sign-and-magnitude
      \item[-] Normalized, one hidden bit
    \end{itemize}

  \end{itemize}

  \[
x = (-1)^S \times \left(1 + \sum_{i=1}^{n} M_{n-i}2^{-i} \right) \times 2^{\left(\sum_{j=0}^{m-1} E_j2^j\right) - (2^{m-1} - 1)}
\]
\subsection{Rounding}
\begin{itemize}
    \item[] The result of a floating-point operation is a real number that, to be represented exactly, might require a significand with an infinite number of digits.
    \begin{itemize}
        \item[] For a representation close to the exact result, we perform \textbf{rounding}.
    \end{itemize}
    \item[] Consider the real number \( x_{\text{real}} \) and the consecutive floating-point numbers \( F_1 \) and \( F_2 \), such that \( F_1 \leq x_{\text{real}} \leq F_2 \).
    \begin{itemize}
        \item[] We can perform several types of rounding:
        \begin{itemize}
            \item[] Round to nearest (tie to even)
            \item[] Round towards zero (truncation)
            \item[] Round towards plus or towards minus infinity
        \end{itemize}
    \end{itemize}
\end{itemize}
\begin{itemize}
    \item[-] Round to nearest (tie to even)
    \[ R_{\text{near}}(x_{\text{real}}) = 
    \begin{cases} 
    F_1, & \text{if } |x_{\text{real}} - F_1| < |x_{\text{real}} - F_2| \\
    F_2, & \text{if } |x_{\text{real}} - F_1| > |x_{\text{real}} - F_2| \\
    \text{even}(F_1, F_2), & \text{if } |x_{\text{real}} - F_1| = |x_{\text{real}} - F_2|
    \end{cases}
    \]
    
    \item[-] Round towards zero (truncation)
    \[ R_{\text{zero}}(x_{\text{real}}) = 
    \begin{cases} 
    F_1, & \text{if } x_{\text{real}} \geq 0 \\
    F_2, & \text{if } x_{\text{real}} < 0
    \end{cases}
    \]
    
    \item[-] Round towards plus or minus (negative) infinity
    \[ R_{\text{pinf}}(x_{\text{real}}) = F_2 \]
    \[ R_{\text{ninf}}(x_{\text{real}}) = F_1 \]
\end{itemize}

\section*{Examples of Rounding Methods}

Let's consider \( x_{\text{real}} = 2.5 \), \( F_1 = 2 \), and \( F_2 = 3 \) for our examples.

\subsection*{Round to nearest (tie to even)}
\[ R_{\text{near}}(2.5) = \text{even}(2, 3) = 2 \]
Since both \( F_1 \) and \( F_2 \) are equidistant from \( x_{\text{real}} \), we choose the even number which is \( 2 \).

\subsection*{Round towards zero (truncation)}
\[ R_{\text{zero}}(2.5) = 2 \]
Since \( x_{\text{real}} \) is positive, we round towards zero, resulting in \( F_1 \).

\subsection*{Round towards plus infinity}
\[ R_{\text{pinf}}(2.5) = 3 \]
When rounding towards plus infinity, we choose \( F_2 \).

\subsection*{Round towards minus infinity}
\[ R_{\text{ninf}}(2.5) = 2 \]
When rounding towards minus infinity, we choose \( F_1 \).

Now let's consider a negative value \( x_{\text{real}} = -2.5 \), \( F_1 = -3 \), and \( F_2 = -2 \).

\subsection*{Round towards zero (truncation) for negative value}
\[ R_{\text{zero}}(-2.5) = -2 \]
Since \( x_{\text{real}} \) is negative, we round towards zero, resulting in \( F_2 \).

\subsection*{Round towards plus infinity for negative value}
\[ R_{\text{pinf}}(-2.5) = -2 \]
When rounding towards plus infinity for a negative number, we choose the larger number, which is \( F_2 \).

\subsection*{Round towards minus infinity for negative value}
\[ R_{\text{ninf}}(-2.5) = -3 \]
When rounding towards minus infinity for a negative number, we choose the smaller number, which is \( F_1 \).


\newpage 
\section{IEEE 754 Standard}
\section*{FP Format in IEEE 754}

Exactly what we described:
\begin{itemize}
    \item[] \( (n + 1) \)-bit significand
    \begin{itemize}
        \item Sign-and-magnitude
        \item Normalized, one hidden bit
    \end{itemize}
    \item[] \( m \)-bit exponent
    \begin{itemize}
        \item Biased, \( B = 2^{m-1} - 1 \)
    \end{itemize}
\end{itemize}

Let \( X \) a digit-vector represented as:
\[ X = (S E_{m-1} E_{m-2} \ldots E_1 E_0 . M_{n-1} M_{n-2} \ldots M_1 M_0) \]

\underline{Basic and extended formats:}
\begin{itemize}
    \item[+] Basic formats:
    \begin{itemize}
        \item Single precision (32 bits)
        \begin{itemize}
            \item Sign \( S \): 1 bit
            \item Exponent \( E \): 8 bits
            \item Fraction \( F \): 23 bits
        \end{itemize}
        \item Double precision (64 bits)
        \begin{itemize}
            \item Sign \( S \): 1 bit
            \item Exponent \( E \): 11 bits
            \item Fraction \( F \): 52 bits
        \end{itemize}
    \end{itemize}
    \item[+] Default round to nearest (ties to even)
\end{itemize}

\newpage
\subsection{Special Values}
The IEEE 754 standard defines special values with unique bit patterns:

\begin{description}
    \item[Floating-point zero:] is represented by all zeros in both the exponent and the significand fields.
    \begin{align*}
        \text{Positive zero: } &0 \quad 00000000 \quad 00000000000000000000000 \\
        \text{Negative zero: } &1 \quad 00000000 \quad 00000000000000000000000
    \end{align*}
    The most significant bit (the sign bit) differentiates between positive and negative zero.

    \item[Positive and negative infinity:] are represented by all ones in the exponent field and all zeros in the significand field.
    \begin{align*}
        \text{Positive infinity: } &0 \quad 11111111 \quad 00000000000000000000000 \\
        \text{Negative infinity: } &1 \quad 11111111 \quad 00000000000000000000000
    \end{align*}

    \item[NaN (Not a Number):] is represented by all ones in the exponent field and a non-zero significand field.
    \begin{align*}
        \text{NaN (example): } &- \quad 11111111 \quad 10000000000000000000000
    \end{align*}
    NaN values represent indeterminate or undefined results, such as the square root of a negative number. The sign bit can be either 0 or 1, but the significand must not be all zeros.
\end{description}

\subsection{Overflow, underflow, and others}
\begin{description}
    \item[Overflow:] Occurs when the rounded value is too large to be represented by the floating-point format.
    \begin{itemize}
        \item The result is set to positive or negative infinity, depending on the sign.
    \end{itemize}
    
    \item[Underflow:] Happens when the rounded value is too small to be represented.
    \begin{itemize}
        \item Typically, the result is set to a denormalized number or zero.
    \end{itemize}
    
    \item[Division by zero:] Occurs when a finite non-zero number is divided by zero.
    \begin{itemize}
        \item The result is set to positive or negative infinity, based on the sign of the numerator.
    \end{itemize}
    
    \item[Inexact result:] Occurs when the result of an operation is not an exact floating-point number.
    \begin{itemize}
        \item The result is rounded to the nearest representable value.
    \end{itemize}
    
    \item[Invalid:] This flag is set when the result of an operation is not a real number (NaN).
    \begin{itemize}
        \item Examples include the square root of a negative number or the indeterminate form 0/0.
    \end{itemize}
\end{description}

\section*{IEEE 754}
\subsection*{Example: Converting single-precision FP to decimal}

Find the decimal equivalent of
\[ X = (1\ 01111100\ 01000000000000000000000) \]

Solution:
\begin{itemize}
    \item[-] Sign \( S = 1 \), hence negative.
    \item[-] Exponent \( E = 01111100 \) represents the biased exponent. To find the actual exponent:
    \[ E_{\text{actual}} = 124 - (2^7 - 1) = 124 - 127 = -3 \]
    \item[-] Mantissa (including the hidden bit) \( M = 1.01 \) in binary represents:
    \[ M = 1 + 2^{-2} = 1.25 \]
    \item[-] Result:
    \[ x = -1.25 \times 2^{-3} = -0.15625 \]
\end{itemize}

\subsection*{Example: Converting decimal to single-precision FP}

Find the single-precision FP equivalent of \( x = -0.8125 \)

Solution:
\begin{itemize}
    \item[-] Sign \( = 1 \), negative.
    \item[-] Fraction bits can be obtained using multiplication by 2.
    \item[-] Converting \( 0.8125 \) to binary by successive multiplication:
    \begin{align*}
        0.8125 \times 2 &= 1.625 \rightarrow 1 \\
        0.625 \times 2 &= 1.25 \rightarrow 1 \\
        0.25 \times 2 &= 0.5 \rightarrow 0 \\
        0.5 \times 2 &= 1.0 \rightarrow 1
    \end{align*}
    Stop when the fractional part becomes zero.
    \item[-] Mantissa \( M \) in binary is \( 0.1101 \), normalized is \( 1.101 \times 2^{-1} \).
    \item[-] Exponent adjustment:
    \[ E_{\text{actual}} = -1 \]
    \[ E = E_{\text{actual}} + B = -1 + (2^7 - 1) = 126 \]
    \item[-] Result:
    \[ X = (1\ 01111110\ 10100000000000000000000) \]
\end{itemize}


\chapter{Number Systems (Part IV)}
\section{Fixed Point Arithmetic}
\subsection{Addition and Subtraction}

Let \( x \) and \( y \) be two fixed-point numbers with the same number of integer and fractional bits. The sum and difference of \( x \) and \( y \) can be calculated as follows:
 $$x + y = x_{int} + y_{int} + x_{fr} + y_{fr}$$ 
 $$x - y = x_{int} - y_{int} + x_{fr} - y_{fr}$$

\subsection*{Examples}

\subsection*{Addition}
\begin{align*}
& \phantom{X} & & \; \; \; 011011 & &(Carry) \\
& & &000101.110 & &= 5.75 \\
& & &001100.011 & &= 12.375 \\
&\cline{2-4}
& & &010010.001 & &= 18.125
\end{align*}
        
\subsection*{Substraction}

\begin{align*}
    & \phantom{-}1110000\ 110 & & (Carry) \\
    & \phantom{-}000101.110 &&= 5.75 \\
    & -001100.011 &&= 12.375 \\
    &\cline{2-4}
    & \phantom{000}111001.011 &&= -6.625
    \end{align*}

\newpage
\subsection*{In two's complement}
Given two fixed-point numbers $x$ and $y$, the addition or subtraction in two's complement is given by:
\begin{equation}
x \pm y = \left( -X_{(m_x-1)}2^{(m_x-1)} + \sum_{i=-f_x}^{m_x-2} X_i2^i \right) \pm \left( -Y_{(m_y-1)}2^{(m_y-1)} + \sum_{i=-f_y}^{m_y-2} Y_i2^i \right)
\end{equation}

Where:
\begin{itemize}
    \item[] $m_x$ and $m_y$ are the total number of bits for the integer components of $x$ and $y$ respectively.
    \item[] $f_x$ and $f_y$ are the number of bits for the fractional components of $x$ and $y$ respectively.
    \item[] $X_{(m_x-1)}$ and $Y_{(m_y-1)}$ are the sign bits of $x$ and $y$.
    \item[] The largest integer-part exponent is $\max(m_x - 1, m_y - 1)$. Consequently, the number of bits for the resulting integer component is $\max(m_x, m_y) + 1$.
    \item[] The smallest fractional-part exponent is $\min(-f_x, -f_y)$. Consequently, the number of bits for the resulting fractional component is $\max(f_x, f_y)$.
\end{itemize}

\subsection{Multiplication}


\begin{align*}
    \begin{array}{r@{}c@{}l}
        & 010.11 & \text{\quad Multiplicand} \\
      \times & 011.01 & \text{\quad Multiplier} \\ \cline{1-2}
        & 000000 & \text{\quad First partial product (always zero), sign-extended} \\ 
      + & \; \; \; \; 001011\phantom{.00} & \text{\quad 1 x multiplicand, sign-extended} \\ \cline{1-2}
        & 001011 & \text{\quad Intermediate result, sign-extended} \\ 
      + & \phantom{0}00000\phantom{.0} & \text{\quad 0 x multiplicand, left-shifted by 1 place and sign-extended} \\ \cline{1-2}
        & 00001011\phantom{} & \text{\quad Intermediate result, sign-extended} \\ 
      + & \phantom{00}001011\phantom{000} & \text{\quad 1 x multiplicand, left-shifted by 2 places and sign-extended} \\ \cline{1-2}
        & 00010111 & \text{\quad Intermediate result, sign-extended} \\ 
      + & 001011\phantom{00} & \text{\quad 1 x multiplicand, left-shifted by 3 places and sign-extended} \\ \cline{1-2}
        & 001001111 & \text{\quad Intermediate result, sign-extended} \\ 
      + & 000000\phantom{00}& \text{\quad 0 x multiplicand, left-shifted by 4 places and sign-extended} \\ \cline{1-2}
        & 0010001111 & \text{\quad Result, integer} \\
    \end{array} & \text{\quad convert to fixed-point now}
 \end{align*}

\newpage

\subsection*{Multiplication in Two's Complement}
\begin{itemize}
    \item[] Multiplication on two binary numbers \( x(m_x, f_x) \) and \( y(m_y, f_y) \)
    \begin{equation*}
      x \cdot y = (x_{\text{int}} + x_{\text{fr}}) \cdot (y_{\text{int}} + y_{\text{fr}})
    \end{equation*}
  
    \item[] In two's complement:
    \begin{equation*}
      x \cdot y = \left( -X_{m_x-1}2^{m_x-1} + \sum_{i=-f_x}^{m_x-2} X_i2^i \right) \cdot \left( -Y_{m_y-1}2^{m_y-1} + \sum_{i=-f_y}^{m_y-2} Y_i2^i \right)
    \end{equation*}
    
    \item[] \small The largest integer-part exponent: \( (m_x - 1) + (m_y - 1) \). Consequently: \( m_{xy} = m_x + m_y \)
    
    \item[] \small The smallest fractional-part exponent: \( (-f_x) + (-f_y) \). Consequently: \( f_{xy} = f_x + f_y \)
    
  \end{itemize}

\section{Floating-Point Arithmetic}

    
    
    \begin{itemize}
      \item[] Let \( x \) and \( y \) be represented as \( (S_x, M_x, E_x) \) and \( (S_y, M_y, E_y) \)
      \begin{itemize}
        \item[] The significands \( M^* = (-1)^S M \) are normalized
      \end{itemize}
      
      \item[] Addition/subtraction result is \( z \), also represented as \( (S_z, M_z, E_z) \):
      \[ z = x \pm y = M^*_x \times 2^{E_x} \pm M^*_y \times 2^{E_y} \]
      
      \begin{itemize}
        \item[] The significand of the result is also normalized
        \[ z = M^*_z \times 2^{E_z} \]
      \end{itemize}
    \end{itemize}
    

    \newpage
    \begin{itemize}
        \item[] \textbf{Four main steps to compute the result of floating-point addition/subtraction:}
        \begin{enumerate}
            \item \textbf{Add/Subtract significand and set exponent:}
            \begin{itemize}
                \item Align the significands by shifting the one with the \textit{smaller} exponent.
                \item Perform addition/subtraction on the aligned significands.
            \end{itemize}
            \[
            M_z^* = 
            \begin{cases} 
                (M_x^* + (M_y^* \times 2^{(E_y - E_x)})) \times 2^{E_x} & \text{if } E_x \geq E_y \\
                ((M_x^* \times 2^{(E_x - E_y)}) + M_y^*) \times 2^{E_y} & \text{if } E_x < E_y
            \end{cases}
            \]
            \[
            E_z = \max(E_x, E_y)
            \]
      
            \item \textbf{Normalize the result and update the exponent, if required:}
            \begin{itemize}
                \item Check if the result's significand is within the normalized range.
                \item If not, shift the significand to the right or left until it is normalized, adjusting the exponent accordingly to maintain the value.
            \end{itemize}
    
            \item \textbf{Round the result, normalize, and adjust exponent, if required:}
            \begin{itemize}
                \item Apply rounding rules to the significand to fit within the precision limits.
                \item After rounding, if the significand overflows (e.g., carries out during addition), normalize the result again and adjust the exponent.
            \end{itemize}
    
            \item \textbf{Set flags for special values, if required:}
            \begin{itemize}
                \item Check for overflow or underflow conditions and set flags accordingly.
                \item Identify and mark results that are special values (e.g., infinity, NaN) based on the operation and input values.
            \end{itemize}
        \end{enumerate}
    \end{itemize}
    
    \section*{Step 1: Floating-Point Addition/Subtraction Detailed Algorithm}
    \begin{itemize}
        \item[] Algorithm steps:
        \begin{itemize}
            \item Subtract exponents \(d = E_x - E_y\).
            \item Align significands:
            \begin{itemize}
                \item Compare the exponents of the two operands.
                \item Shift right \(d\) positions the significand of the operand with the smallest exponent.
                \item Select as the exponent of the result the largest exponent.
            \end{itemize}
            \item Add/subtract signed significands and produce the sign of the result.
        \end{itemize}
    \end{itemize}
    
    \begin{table}[h]
    \centering
    \caption{Floating-point operations based on the signs of the operands.}
    \begin{tabular}{ccc}
    \toprule
    FP operation & Signs of the operands & Effective operation \\
    \midrule
    \(+\)        & \(=\)                 & add                 \\
    \(+\)        & \(\neq\)              & subtract            \\
    \(-\)        & \(=\)                 & subtract            \\
    \(-\)        & \(\neq\)              & add                 \\
    \bottomrule
    \end{tabular}
    \end{table}
    
    \section*{Step 2: Normalize the Result}
    After the initial addition or subtraction, the result may not always be in the normalized form required by floating-point representation standards. Normalization ensures that the significand (mantissa) is within a specific range, usually just below 1 (for binary floating-point numbers, this means the leading bit is just to the right of the decimal point).
    
    \begin{itemize}
        \item[] Steps for normalization:
        \begin{itemize}
            \item If the result of the operation causes the significand to exceed its predefined size (overflow), the significand is shifted to the right, and the exponent is increased accordingly.
            \item Conversely, if the operation results in a significand that's too small (underflow), the significand is shifted to the left, and the exponent is decreased.
            \item This process ensures that the floating-point number is as close to its true value as possible within the limits of the representation.
        \end{itemize}
    \end{itemize}
    \section*{Step 3: Round the Result}

    After normalization, the next step is to round the result to fit within the target floating-point format's precision. Rounding is crucial because it affects the accuracy and representation of the result.
    
    \begin{itemize}
        \item[] Steps for rounding:
        \begin{itemize}
            \item Evaluate the significand's precision and compare it with the format's limit.
            \item If the significand exceeds the precision limit, round it according to a rounding rule (e.g., round to nearest, round towards zero, round towards positive/negative infinity).
            \item Common rounding strategies include:
            \begin{itemize}
                \item \textbf{Round to Nearest:} Round to the nearest value, with ties going to the nearest even number.
                \item \textbf{Round Down (Towards Zero):} Always round towards zero, truncating any fractional part.
                \item \textbf{Round Up (Away from Zero):} Always round away from zero, increasing the magnitude of the result.
            \end{itemize}
            \item After rounding, if there's an overflow in the significand (e.g., a carry into a new digit), normalize the result again. This may involve shifting the significand and adjusting the exponent.
        \end{itemize}
    \end{itemize}
    
    \section*{Step 4: Set Flags for Special Values}
    
    The final step in floating-point addition or subtraction involves handling special cases and setting flags accordingly. Special values include infinity, not-a-number (NaN), and potential overflow or underflow conditions.
    
    \begin{itemize}
        \item[] Handling special values:
        \begin{itemize}
            \item \textbf{Infinity:} If the result of the operation is too large to be represented in the given floating-point format, set the result to infinity. The sign of infinity depends on the operation and operands.
            \item \textbf{NaN (Not-a-Number):} If the operation involves invalid operations (e.g., \(0/0\), \(\infty - \infty\)), set the result to NaN. NaN propagates through most floating-point operations.
            \item \textbf{Overflow:} If the result exceeds the maximum representable value, set an overflow flag. The result is typically set to infinity with the appropriate sign.
            \item \textbf{Underflow:} If the result is too small to be represented (closer to zero than the smallest representable value), set an underflow flag. The result may be set to zero or the smallest denormalized number, depending on the format and flags.
        \end{itemize}
    \end{itemize}


    \subsection{An Example in Binary}

Let's add two binary floating-point numbers: $1.01 \times 2^3$ and $1.1 \times 2^2$. Here's how we do it step by step:

\begin{enumerate}
    \item \textbf{Line Up the Dots:} First, we need to align the exponents. We'll adjust the second number to have the same exponent as the first, by increasing its exponent and shifting its significand to the right: 
    \[
    1.1 \times 2^2 = 0.11 \times 2^3
    \]
    Now, both numbers are $1.01 \times 2^3$ and $0.11 \times 2^3$.

    \item \textbf{Add Them Up:} With the exponents aligned, we can now add the significands:
    \[
    1.01 + 0.11 = 10.00
    \]
    The result in binary is $10.00$. Since we're working in binary, $10.00$ is actually $2$ in decimal. 

    \item \textbf{Make It Look Right:} The result $10.00 \times 2^3$ is already in the correct format, but let's note that if our result was something like $1.000 \times 2^4$, we would need to adjust it to keep it in normalized form.

    \item \textbf{Round It Off:} Our result doesn't need rounding in this case, but if we had more digits than we could store, we'd round off to the nearest value we could represent.

    \item \textbf{Check for Special Cases:} There are no special cases here, as our result is a regular binary floating-point number.
\end{enumerate}

So, our final result is $10.00 \times 2^3$ in binary, which is $8$ in decimal.


\chapter{Number Systems (Part V)}




\begin{text}
    This small chapter concludes the Number Systems chapter with a some modern applications of low precision computing.
\end{text}
\section{Low precision computer arithmetic}


\begin{itemize}
  \item[] AI is taking on an increasingly important role
  \item[] Deep Neural Networks (DNNs) are the most widespread
  \begin{itemize}
    \item[] E.g., Large Language Models (LLM) generate human-like content
  \end{itemize}
  \item[] Challenge: exponential size growth
  \begin{itemize}
    \item[] GPT3 has 175 billion parameters
  \end{itemize}
  \item[] Large models mean
  \begin{itemize}
    \item[] A lot of data, any computations
    \item[] ...and we want the result quickly!
    \item[] Luckily, ML models are tolerant to small errors
  \end{itemize}
\end{itemize}

\section{Challenges and limitations}
\begin{itemize}
    \item[] 32-bit or 64-bit floating-point formats
    \begin{itemize}
      \item[] Arithmetic units are large (many bits $\Rightarrow$ high area, high energy)
      \item[] We can put fewer units per chip (e.g., less compute power in GPU)
        \begin{itemize}
          \item[] Poor arithmetic density (in number of ops / 1mm$^2$)
          \item[] Fewer units, fewer computations
        \end{itemize}
      \item[] The model predictions are accurate, but it takes a long time to compute them
    \end{itemize}
    \item[] Fixed-point or integer formats
    \begin{itemize}
      \item[] Arithmetic units are smaller and faster (approx. 10x area savings)
      \item[] Better arithmetic density and lower delays
      \item[] The errors due to limited dynamic range are too significant for most ML models; the accuracy of their predictions suffers
    \end{itemize}
    \item[] New number formats are needed: the best of both worlds
  \end{itemize}



  \section{Block Floating Point}
  \section*{Block Floating Point}

Imagine a block (vector) of binary numbers in FP (Floating Point) format, where each vector element has its own S (Sign), M (Mantissa), and E (Exponent).

\[
\begin{array}{|c|c|c|}
\hline
S_1 & E_1 & M_1 \\
\hline
S_2 & E_2 & M_2 \\
\hline
\vdots & \vdots & \vdots \\
\hline
S_n & E_n & M_n \\
\hline
\end{array}
\]

If the exponents in the block are not too different, we could use a single shared exponent per block.

\begin{tikzpicture}
    \node (E) at (0,0) {$E_{\text{block}}$ (shared)};
    \node (S1) at (3,0.5) {$S_1$};
    \node (M1) at (4,0.5) {$M_1$};
    \node[draw,fit=(S1) (M1),inner sep=1.65mm] (table1) {}; % Drawing a rectangle around S1 and M1
    \node (S2) at (3,-0.5) {$S_2$};
    \node (M2) at (4,-0.5) {$M_2$};
    \node[draw,fit=(S2) (M2),inner sep=1.75mm] (table1) {}; % Drawing a rectangle around S1 and M1
    \node (Sn) at (3,-1.5) {$S_n$};
    \node (Mn) at (4,-1.5) {$M_n$};
    \node[draw,fit=(Sn) (Mn),inner sep=1.65mm] (table1) {}; % Drawing a rectangle around S1 and M1

    \draw[->] (E) -- (S2);
    \draw[->] (E) -- (S1);
    \draw[->] (E) -- (Sn);
    \end{tikzpicture}
    

\textit{In BFP with shared Exponent:}
\begin{itemize}
    \item[] Find the largest exponent in the block of FP numbers. This will be the shared exponent \( E_{\text{block}} \).
    \item[] Calculate the difference \( d_i = E_{\text{block}} - E_i \) between the shared exponent and each of the other exponents \( E_i \) in the block.
    \item[] Adjust the mantissa by right-shifting the signed mantissa of each number by \( d_i \). As a result of these adjustments, the mantissa in BFP cannot be normalized, and there is no hidden bit.
\end{itemize}

\chapter{Digital Logic Circuits}
\section{Introduction to Digital Logic Circuits}
The smallest unit of Digital Information is a binary value 1 or 0.
\subsection{The simplest binary logic element}
Similarly, a switch can either be open or closed. 
Let $x$ an input variable.
\begin{itemize}
    \item[-] Open ($x=0$) \;
    \begin{tikzpicture}
        \draw (0,0) -- (2,0);
        \draw (2,0) -- (2.5,0.5);
        \draw (3,0) -- (4,0);
        \filldraw [black] (2,0) circle (2pt);
        \filldraw [black] (3,0) circle (2pt);
    \end{tikzpicture}

    \item[-] Closed ($x=1$)
    \begin{tikzpicture}
        \draw (0,0) -- (2,0);
        \draw (2,0) -- (4,0);
        \filldraw [black] (2,0) circle (2pt);
        \filldraw [black] (3,0) circle (2pt);

    \end{tikzpicture}
\end{itemize}

\vspace*{10px}

The symbol for a switch controlled by an input variable:

\vspace*{10px}
\hspace*{130px}
\begin{tikzpicture}
    \draw (0,0) -- (1,0) -- (1.5,0) -- (2,0) -- (3,0);
    \draw (1.5,0) -- (1.5,-0.5);
    
    \draw (1,0) -- (1,1) -- (2,1) -- (2,0);
    \node at (1.5,0.5) {$S$};
    \node at (1.5,-0.75) {$x$};
\end{tikzpicture}


\subsection{The simplest binary logic element}


\begin{figure}[htp] % This line sets the wrapfigure environment to place the figure on the right side and occupy half the text width
    \centering
    \includegraphics[width=0.41\textwidth]{circuits/6.1.2.png} % Replace 'path_to_image.png' with the actual path to your image file
    \caption{Light controlled by a single switch}
  \end{figure}


\newpage
\section*{Two-Variable Logic Functions}
\textbf{Series and Parallel Connections}
\newline
\vspace{10px}
\textit{Remark. The choice of symbols is not random $\cdot, +,$ respectively similar to multiplication and addition.}
\vspace{20px}
\begin{figure}[htp] % This line sets the wrapfigure environment to place the figure on the right side and occupy half the text width
    \centering
    \includegraphics[width=0.41\textwidth]{circuits/6.1.3.png} % Replace 'path_to_image.png' with the actual path to your image file
    \caption{Logic AND function}
    \text{$L(x_{1}, x_{2}) = x_{1} \cdot x_{2}$, with $\cdot$ the AND operator}
  \end{figure}


 

\begin{figure}[htp] % This line sets the wrapfigure environment to place the figure on the right side and occupy half the text width
    \centering
    \includegraphics[width=0.5\textwidth]{circuits/6.1.3_2.png} % Replace 'path_to_image.png' with the actual path to your image file
    \caption{Circular representation of two's complement}
    \text{$L(x_{1}, x_{2}) = x_{1} + x_{2}$, with $+$ the OR operator}
  \end{figure}


\begin{figure}[htp] % This line sets the wrapfigure environment to place the figure on the right side and occupy half the text width
    \centering
    \includegraphics[width=0.5\textwidth]{circuits/6.1.3_3.png} % Replace 'path_to_image.png' with the actual path to your image file
    \caption{A series-parallel connection of three switches}
    \text{The corresponding Logic Function is $L(x_{1}, x_{2}, x_{3}) = (x_{1} + x_{2}) \cdot x_{3}$} \newline
    \textit{Smaller circuits separated by parentheses}
  \end{figure}


  \begin{figure}[htp]
    \centering
    \includegraphics[width=0.5\textwidth]{circuits/6.1.3_4.png} % Adjust the path to your image
    \caption{NOT GATE} % Caption for the figure
    \label{fig:notgate} % Label for referencing the figure in the text
    \medskip % Adds some vertical space (optional)
    \text{The corresponding Logic Function is \(L(x) = \bar{x}\), \textit{ with \(\bar{x}\) the complement of \(x\).}}
  \end{figure}
  \newpage
  \section{Truth Tables}
  Logical operations can be defined in the form of a truth table
  \begin{itemize}
      \item[] AND
      \begin{equation*}
          L(x_1, x_2) = x_1 \cdot x_2
      \end{equation*}
      where \( L = 1 \) if \( x_1 = 1 \) and \( x_2 = 1 \), \( L = 0 \) otherwise.
      
      \item[] OR
      \begin{equation*}
          L(x_1, x_2) = x_1 + x_2
      \end{equation*}
      where \( L = 1 \) if \( x_1 = 1 \) or \( x_2 = 1 \), or if \( x_1 = x_2 = 1 \), \( L = 0 \) if \( x_1 = x_2 = 0 \).
  \end{itemize}
  
  \begin{center}
  \begin{tabular}{ c c | c | c }
      \( x_1 \) & \( x_2 \) & AND & OR \\
      \hline
      0 & 0 & 0 & 0 \\
      0 & 1 & 0 & 1 \\
      1 & 0 & 0 & 1 \\
      1 & 1 & 1 & 1 \\
      
  \end{tabular}
\end{center}


\textit{For n logical variables we get $2^n$ rows}.\newline
For example : 
\begin{itemize}
  \item[] AND
  \begin{equation*}
      L(x_1, x_2, x_3) = x_1 \cdot x_2 \cdot x_3
  \end{equation*}
  where \( L = 1 \) if \( x_1 = x_2 = x_3 = 1 \), \( L = 0 \) otherwise.
  
  \item[] OR
  \begin{equation*}
      L(x_1, x_2, x_3) = x_1 + x_2 + x_3
  \end{equation*}
  where \( L = 0 \) if \( x_1 = x_2 = x_3 = 0 \), \( L = 1 \) otherwise.
\end{itemize}

\begin{center}
\begin{tabular}{ c c c | c | c }

  \( x_1 \) & \( x_2 \) & \( x_3 \) & AND & OR \\
  \hline
  0 & 0 & 0 & 0 & 0 \\
  0 & 0 & 1 & 0 & 1 \\
  0 & 1 & 0 & 0 & 1 \\
  0 & 1 & 1 & 0 & 1 \\
  1 & 0 & 0 & 0 & 1 \\
  1 & 0 & 1 & 0 & 1 \\
  1 & 1 & 0 & 0 & 1 \\
  1 & 1 & 1 & 1 & 1 \\
\end{tabular}
\end{center}
\begin{itemize}
\item[] NOT, with $L(x) = \bar{x}$      
\end{itemize}
\begin{center}
    \begin{tabular}{ c c | c | c }
        \( x \) & \( \bar{x} \) & NOT \\
        \hline
        0 & 0 & 0 \\
        0 & 1 & 0 \\
    \end{tabular}
  \end{center}

  \subsection*{Precedence Table for Logic Operations}

  \begin{center}
    \begin{tabular}{cccl}
    \toprule
    \textbf{Precedence (Priority)} & \textbf{Operator} & \textbf{Operation} & \textbf{Description} \\
    \midrule
    1 & \(\overline{x}\) & NOT & Negation of A \\
    2 & \(x_{1} \cdot x_{2}\) & AND & Conjunction of A and B \\
    3 & \(x_{1} + x_{2}\) & OR & Disjunction of A and B \\
    \bottomrule
    \end{tabular}
    \end{center}

    \section{Logic Gates}


\end{document}